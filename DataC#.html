<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Типы и переменные</title>
    <link rel="stylesheet" type="text/css" href="TextBoxCSS.css">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
</head>
<body>
<div class="main">
    <div class="header">
        <ul>
            <li><a href="С%23TextBox.html">Вступление</a></li>
            <li><a href="Struktur.html">Структура</a></li>
            <li><a href="DataC%23.html" id="active">Типы и переменные</a></li>
            <li><a href="ComandIF.html">Операторы</a></li>
            <li><a href="Massiv.html">Массивы</a></li>
            <li><a href="Class.html">Классы в C#</a></li>
        </ul>
        <ul id="text">
            <p>На странице:</p>
            <li><a href="#Type">Типы и переменные</a></li>
            <li><a href="#bool">Тип bool</a></li>
            <li><a href="#class">Тип class</a></li>
            <li><a href="#struct">Тип struct</a></li>
            <li><a href="#interface">Тип interface </a></li>
            <li><a href="#delegate">Тип delegate </a></li>
            <li><a href="#NULL">Тип NULL </a></li>
        </ul>
    </div>
    <div class="content">
        <h1>Учебник по C#</h1>
        <h2 id="Type">Типы и переменные</h2>
        <p>В C# существуют две разновидности типов: ссылочные типы и типы значений. Переменные типа значений содержат непосредственно данные, а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами. Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная. Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров ref и out).</p>
        <p>Типы значений в C# подразделяются на простые типы, типы перечисления, типы структур и типы, допускающие значение NULL. Ссылочные типы в C# подразделяются на типы классов, типы интерфейсов, типы массивов и типы делегатов.</p>
        <p>Далее представлены общие сведения о системе типов в C#.</p>
        <ul>
            <li><u>Типы значений</u></li>
            <ul>
                <li>Простые типы</li>
                <ul>
                    <li>Целочисленный со знаком: sbyte, short, int,long</li
                    <li>Целочисленный без знака: byte, ushort, uint,ulong</li>
                    <li>Символы Юникода: char</li>
                    <li>Бинарный оператор IEEE с плавающей запятой: float, double</li>
                    <li>Десятичное значение с повышенной точностью и плавающей запятой: decimal</li>
                    <li>Логическое значение: bool</li>
                </ul>
                <li>Типы перечисления</li>
                <li>Типы структур</li>
                <li>Типы значений, допускающие значение NULL</li>
                <li>Типы значений кортежей</li>
            </ul>
            <li><u>Ссылочные типы</u></li>
            <ul>
                <li>Типы классов</li>
                <li>Типы интерфейсов</li>
                <li>Типы массивов</li>
                <li>Типы делегатов</li>
            </ul>
        </ul>
        <p id="bool">Тип bool в C# используется для представления логических значений, которые могут иметь значение true или false.</p>
        <p>Обработка знаков и строк в C# выполняется в кодировке Юникода. Тип char представляет элемент в кодировке UTF-16, а тип string представляет последовательность элементов в кодировке UTF-16.</p>
        <p>Программы C# используют объявления типов для создания новых типов. В объявлении типа указываются имя и члены нового типа. Пять категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления и типы делегатов.</p>
        <p id="class">Тип class определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.). Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</p>
        <p id="struct">Тип struct похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами. Но, в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи. Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа object.</p>
        <p id="interface">Тип interface (интерфейс) определяет контракт в виде именованного набора открытых функций-членов. Объект типа class или struct, реализующий interface, должен предоставить реализации для всех функций-членов интерфейса. Тип interface может наследовать от нескольких базовых интерфейсов, а class или struct могут реализовывать несколько интерфейсов.</p>
        <p id="delegate">Тип delegate (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Делегаты аналогичны типам функций, которые используются в функциональных языках. Их принцип работы близок к указателям функций из некоторых языков. В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</p>
        <p >Типы class, struct, interface и delegate поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.</p>
        <p>Тип enum является отдельным типом со списком именованных констант. Каждый тип enum имеет базовый тип, в роли которого выступает один из восьми целочисленных типов. Набор значений типа enum аналогичен набору значений его базового типа.</p>
        <p>C# поддерживает одно- и многомерные массивы любого типа. В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием. Типы массивов можно сформировать, просто введя квадратные скобки после имени типа. Например, int[] является одномерным массивом значений типа int, а int[,] — двумерным массивом значений типа int, тогда как int[][] представляет собой одномерный массив одномерных массивов значений типа int.</p>
        <p id="NULL">Типы значений, допускающие значение NULL, также не нужно отдельно объявлять перед использованием. Для каждого обычного типа значений T, который не допускает значение NULL, существует идентичный тип T?, который отличается только тем, что может содержать дополнительное значение null. Например int? — это тип, который может содержать любое 32-разрядное целое число или значение null.</p>
        <p>Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как object (объект). Каждый тип в C# является прямо или косвенно производным от типа класса object, и этот тип object является исходным базовым классом для всех типов. Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип object. Чтобы значения типов значений обрабатывались как объекты, выполняются операции упаковки-преобразования и распаковки-преобразования. В следующем примере значение int преобразуется в object, а затем обратно в int.</p>
        <pre class="hljs" style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(240, 240, 240) none repeat scroll 0% 0%; color: rgb(68, 68, 68);"><span class="hljs-keyword" style="font-weight: 700;">using</span> System;
<span class="hljs-keyword" style="font-weight: 700;">class</span> <span class="hljs-title" style="color: rgb(136, 0, 0); font-weight: 700;">BoxingExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="font-weight: 700;">static</span> <span class="hljs-keyword" style="font-weight: 700;">void</span> <span class="hljs-title" style="color: rgb(136, 0, 0); font-weight: 700;">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword" style="font-weight: 700;">int</span> i = <span class="hljs-number" style="color: rgb(136, 0, 0);">123</span>;
        <span class="hljs-keyword" style="font-weight: 700;">object</span> o = i;    <span class="hljs-comment" style="color: rgb(136, 136, 136);">// Boxing</span>
        <span class="hljs-keyword" style="font-weight: 700;">int</span> j = (<span class="hljs-keyword" style="font-weight: 700;">int</span>)o;  <span class="hljs-comment" style="color: rgb(136, 136, 136);">// Unboxing</span>
    }
}</pre>
        <p>Если значение типа назначается ссылке object, для хранения значения выделяется упаковка. Эта упаковка является экземпляром ссылочного типа, и в нее копируется значение. И наоборот, если ссылка типа object используется для типа значения, для соответствующего object выполняется проверка, является ли он упаковкой правильного типа. Если эта проверка завершается успешно, копируется значение этой упаковки.</p>
        <p>Унифицированная система типов C# фактически позволяет преобразовывать типы значений в ссылки object "по требованию". Такая унификация позволяет применять универсальные библиотеки, использующие тип object, со всеми типами, производными от object, включая как ссылочные типы, так и с типы значений.</p>
    </div>
    <div class="foot1">
        <a href="Struktur.html"><h3>Назад</h3></a>
    </div>
    <div class="foot">
        <a href="ComandIF.html"><h3>Дальше</h3></a>
    </div>
</div>
</body>
</html>